{0 ltl2ba documentation}

{1 The context}

This program has been implemented during the course {i Introduction Ã  la
vÃ©rification} of the University of Bordeaux.

The goal is to implement {!section-algo} used to translate a LTL formula into
an equivalent {!section-genbuch}.

{1 List of modules}

- {{: parser.html} [Parser]} - The LTL parser
- {{: Ltl/index.html} [Ltl]} - The LTL formul
{1:algo The algorithm}

{i This algorithm is taken from the course {e Introduction Ã  la vÃ©rification}
written by {{:https://www.labri.fr/profil/Zeitoun_ID1120210651}Marc Zeitoun}.}

Let Ï† be an LTL formula.

{2 The first phase}

The first phase consists in putting Ï† in {i negation normal form} (NNF), where:

- all negation appear only in front of the atomic propositions,
- only other logical operators [âˆ§], and [âˆ¨] can appear, and
- only the temporal operator [X], [U], and [R] can appear.

To calculate {i nnf(Ï†)}, following rules can be applied recursively -- see
{!val: Ltl.nnf}:

- nnf(Ï) = Ï
- nnf(Â¬Â¬Ï†) = nnf(Ï†)
- nnf(Â¬(Ï† âˆ¨ Ïˆ)) = nnf(Â¬Ï†) âˆ§ nnf(Â¬Ïˆ)
- nnf(Â¬(Ï† âˆ§ Ïˆ)) = nnf(Â¬Ï†) âˆ¨ nnf(Â¬Ïˆ)
- nnf(Â¬XÏ†) = X nnf(Â¬Ï†)
- nnf(Â¬(Ï† U Ïˆ)) = nnf(Â¬Ï†) R nnf(Â¬Ïˆ)
- nnf(Â¬(Ï† R Ïˆ)) = nnf(Â¬Ï†) U nnf(Â¬Ïˆ)

{2 The second phase}

For the second phase, let reassign Ï† as {i nnf(Ï†)} and define ğ’œ = (S, âŸ¶, S{_0},
F{_1}, ..., F{_k}) as the equivalent BÃ¼chi automata of Ï†. An automata state s âˆˆ
S is a subset of sub-formulas of Ï† and the initial state S{_0} is \{Ï†\}.

{3:reduce Reduced subset}

A subset Z of formulas in NNF is {b reduced} if:

- formulas of Z are of the form: p, Â¬q, or XÎ±,
- âŠ¥ âˆ‰ Z, and âˆ€.p âˆˆ AP, \{p, Â¬p\} âŠˆ Z.

{3 Transitions}

In order to define transitions from a state Y, an oriented graph is build from
Y. Let Y = Z âˆª \{Î±\} where Î± is not a {!section-reduce} and is {b maximal} in Y
(i.e. Î± is not a sub-formula of any other such formula of Y).
Edges from Y are:

- If Î± = Î±{_1} âˆ¨ Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_1}\} and Y âŸ¶ Z âˆª \{Î±{_2}\}.
- If Î± = Î±{_1} âˆ§ Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_1}, Î±{_2}\}.
- If Î± = Î±{_1} R Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_1}, Î±{_2}\} and Y âŸ¶ Z âˆª \{XÎ±, Î±{_2}\}.
- If Î± = Î±{_1} U Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_2}\} and Y âŸ¶{^Î±} Z âˆª \{XÎ±, Î±{_1}\}.

The symbol âŸ¶{^Î±} means the edge is {b marked} by Î±.

Then, is defined:

- Red(Y) = \{Z reduced | Y âŸ¶{^*} Z\}
- Red{_Î±}(Y) = \{Z reduced | Y âŸ¶{^*} without using an edge marked by Î±\}

When all formulas in Z are reduced, is defined:

- next(Z) = \{Î± | XÎ± âˆˆ Z\}
- Î£{_Z} the intersection of all p and Â¬p in Z.

Finally, transitions from Y are: \{Y âŸ¶{^Î£{_Z}} next(Z) | Z âŠ† Red(Y)\}. Is added
an {b acceptance condition} for each sub-formula Î± wich is an Until: F{_Î±} =
\{Y âŸ¶{^Î£{_Z}} next(Z) | Y âŠ† Q and Z âŠ† Red{_Î±}(Y)\}.

{3:genbuch Generalized BÃ¼chi automata on transitions}

At the end the automata built, is a generalized BÃ¼chi automata {i on
transitions}: it's similar to generalized BÃ¼chi automata except that {b
acceptance conditions are set of transitions} instead of set of states. A {b
run} from the initial state is accepted, if for each acceptance conditions, it
goes infinitely often through a transition of this condition.

{3 Summary}

The automata ğ’œ = (S, âŸ¶, S{_0}, F{_1}, ..., F{_k}) equivalent to the formula Ï†,
is defined with:

- Initial state: S{_0} = \{Ï†\}
- Transitions from a state Y: \{Y âŸ¶{^Î£{_Z}} next(Z) | Z âŠ† Red(Y)\}
- Acceptance conditions: âˆ€.Î± âˆˆ Ï†, with Î± = Î±{_1} U Î±{_2}: F{_Î±} =
\{Y âŸ¶{^Î£{_Z}} next(Z) | Y âŠ† Q and Z âŠ† Red{_Î±}(Y)\}
