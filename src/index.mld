{0 ltl2ba documentation}

{1 The context}

This program has been implemented during the course {i Introduction Ã  la
vÃ©rification} of the University of Bordeaux.

The goal is to implement {!section-algo} used to translate a LTL formula into
an equivalent {!section-genbuch}.

{1 List of modules}

- {{: parser.html} [Parser]} - The LTL parser
- {{: core.html} [Core]} - The implementation of the algorithm

{1:algo The algorithm}

{i This algorithm is taken from the course {e Introduction Ã  la vÃ©rification}
written by {{:https://www.labri.fr/profil/Zeitoun_ID1120210651}Marc Zeitoun}.}

Let Ï† be an LTL formula.

{2 The first phase}

The first phase consists in putting Ï† in {i negation normal form} (NNF), where:

- all negation appear only in front of the atomic propositions,
- only other logical operators [âˆ§], and [âˆ¨] can appear, and
- only the temporal operator [X], [U], and [R] can appear.

{3 The negation normal form}

To calculate {i nnf(Ï†)}, following rules can be applied recursively -- see
{!val: Core.Ltl.nnf}:

- nnf(Ï) = Ï
- nnf(Â¬Â¬Ï†) = nnf(Ï†)
- nnf(Â¬(Ï† âˆ¨ Ïˆ)) = nnf(Â¬Ï†) âˆ§ nnf(Â¬Ïˆ)
- nnf(Â¬(Ï† âˆ§ Ïˆ)) = nnf(Â¬Ï†) âˆ¨ nnf(Â¬Ïˆ)
- nnf(Â¬XÏ†) = X nnf(Â¬Ï†)
- nnf(Â¬(Ï† U Ïˆ)) = nnf(Â¬Ï†) R nnf(Â¬Ïˆ)
- nnf(Â¬(Ï† R Ïˆ)) = nnf(Â¬Ï†) U nnf(Â¬Ïˆ)

{2:second The second phase}

For the second phase, let reassign Ï† as {i nnf(Ï†)} and define ð’œ = (S, âŸ¶, S{_0},
F{_1}, ..., F{_k}) as the equivalent BÃ¼chi automata of Ï†. An automata state s âˆˆ
S is a subset of sub-formulas of Ï† and the initial state S{_0} is \{Ï†\}.

{3:reduce Reduced subset}

A subset Z of formulas in NNF is {b reduced} if:

- formulas of Z are of the form: p, Â¬q, or XÎ±,
- âŠ¥ âˆ‰ Z, and âˆ€.p âˆˆ AP, \{p, Â¬p\} âŠˆ Z.

{3 Transitions}

In order to define transitions from a state Y, an oriented graph is build from
Y. Let Y = Z âˆª \{Î±\} where Î± is not a {!section-reduce} and is {b maximal} in Y
(i.e. Î± is not a sub-formula of any other such formula of Y).
Edges from Y are:

- If Î± = Î±{_1} âˆ¨ Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_1}\} and Y âŸ¶ Z âˆª \{Î±{_2}\}.
- If Î± = Î±{_1} âˆ§ Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_1}, Î±{_2}\}.
- If Î± = Î±{_1} R Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_1}, Î±{_2}\} and Y âŸ¶ Z âˆª \{XÎ±, Î±{_2}\}.
- If Î± = Î±{_1} U Î±{_2}, Y âŸ¶ Z âˆª \{Î±{_2}\} and Y âŸ¶{^Î±} Z âˆª \{XÎ±, Î±{_1}\}.

The symbol âŸ¶{^Î±} means the edge is {b marked} by Î±.

Then, is defined:

- Red(Y) = \{Z reduced | Y âŸ¶{^*} Z\}
- Red{_Î±}(Y) = \{Z reduced | Y âŸ¶{^*} without using an edge marked by Î±\}

When all formulas in Z are reduced, is defined:

- next(Z) = \{Î± | XÎ± âˆˆ Z\}
- Î£{_Z} the intersection of all p and Â¬p in Z.

Finally, transitions from Y are: \{Y âŸ¶{^Î£{_Z}} next(Z) | Z âŠ† Red(Y)\}. Is added
an {b acceptance condition} for each sub-formula Î± wich is an Until: F{_Î±} =
\{Y âŸ¶{^Î£{_Z}} next(Z) | Y âŠ† S and Z âŠ† Red{_Î±}(Y)\}.

{3:genbuch Generalized BÃ¼chi automata on transitions}

At the end the automata built, is a generalized BÃ¼chi automata {i on
transitions}: it's similar to generalized BÃ¼chi automata except that {b
acceptance conditions are set of transitions} instead of set of states. A {b
run} from the initial state is accepted, if for each acceptance conditions, it
goes infinitely often through a transition of this condition.

{2 Summary}

The automata ð’œ = (S, âŸ¶, S{_0}, F{_1}, ..., F{_k}) equivalent to the formula Ï†,
is defined with:

- Initial state: S{_0} = \{Ï†\}
- Transitions from a state Y: \{Y âŸ¶{^Î£{_Z}} next(Z) | Z âŠ† Red(Y)\}
- Acceptance conditions: âˆ€.Î± âˆˆ Ï†, with Î± = Î±{_1} U Î±{_2}: F{_Î±} =
\{Y âŸ¶{^Î£{_Z}} next(Z) | Y âŠ† S and Z âŠ† Red{_Î±}(Y)\}

{2 Example Ï† = p U Xq}

Let apply the {!section-algo} to the LTL formula Ï† = p U Xq.

Note that Ï† is already in NNF, therefore we can go directly to the
{!section-second}.

Let's calculate transitions from the initial state S{_0} = \{p U Xq\}.
We have the edges of the intermediate oriented graph from S{_0}:

+ S{_0} âŸ¶ \{\} âˆª \{Î±{_2}\} = \{Xq\}
+ S{_0} âŸ¶ {^Ï†} \{\} âˆª \{XÎ±, Î±{_1}\} = \{X(Ï†), p\}

In first edge, \{Xq\} is reduced, therefore the transition: \{Ï†\} âŸ¶{^Î£} \{q\} =
S{_0} âŸ¶{^Î£} \{q\} and the state \{q\} need to be added to ð’œ.

In the second one, \{X(Ï†), p\} is reduced, therefore the transition: \{Ï†\} âŸ¶{^p}
\{Ï†\} = S{_0} âŸ¶{^p} \{Ï†\} needs to be added to ð’œ.

Finally, Red{_Ï†}(S{_0}) = \{Xq\}, because it's the only reduced state reachable
by a non marked edge. Therefore, the acceptance condition: F{_Ï†} = \{S{_0}
âŸ¶{^Î£} next(\{Xq\})\} = \{S{_0} âŸ¶{^Î£} \{q\})\} needs to be added to ð’œ.

Now, let's repeat previous steps for the state \{q\}.

We have Red(\{q\}) = Red_Ï†(\{q\}) = \{q\}, therefore, there is a transition
from \{q\} to next(\{q\}) = \{\} marked with \{q\}.
Same reasoning for the new state \{\}.

At the end, ð’œ is defined with:

- S = \{\{Ï†\}, \{q\}\},
- Î£ = \{p, q\}
- \{Ï†\} âŸ¶{^p} \{Ï†\}, \{Ï†\} âŸ¶{^Î£} \{q\}, \{q\} âŸ¶{^q} \{\} and \{\} âŸ¶{^Î£} \{\}.
- S{_0} = \{Ï†\}
- F{_Ï†} = \{\{Ï†\} âŸ¶{^Î£} \{q\}, \{q\} âŸ¶{^q} \{\}, \{\} âŸ¶{^Î£} \{\} \}

{v

      +-----+   Î£   +-----+  {q}  +----+
   -->| {Ï†} |======>| {q} |======>| {} |
      +-----+       +-----+       +----+
       |   ^                      ||   ^
       \---/                      \\==//
        {p}                         Î£

   ==>: acceptance condition
v}
