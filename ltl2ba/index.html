<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ltl2ba.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ ltl2ba</nav><header class="odoc-preamble"><h1 id="ltl2ba-documentation"><a href="#ltl2ba-documentation" class="anchor"></a>ltl2ba documentation</h1></header><nav class="odoc-toc"><ul><li><a href="#the-context">The context</a></li><li><a href="#list-of-modules">List of modules</a></li><li><a href="#algo">The algorithm</a><ul><li><a href="#the-first-phase">The first phase</a></li><li><a href="#the-second-phase">The second phase</a><ul><li><a href="#reduce">Reduced subset</a></li><li><a href="#transitions">Transitions</a></li><li><a href="#genbuch">Generalized BÃ¼chi automata on transitions</a></li><li><a href="#summary">Summary</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="the-context"><a href="#the-context" class="anchor"></a>The context</h2><p>This program has been implemented during the course <i>Introduction Ã  la vÃ©rification</i> of the University of Bordeaux.</p><p>The goal is to implement <a href="#algo">The algorithm</a> used to translate a LTL formula into an equivalent <a href="#genbuch">Generalized BÃ¼chi automata on transitions</a>.</p><h2 id="list-of-modules"><a href="#list-of-modules" class="anchor"></a>List of modules</h2><ul><li><a href="parser.html"><code>Parser</code></a> - The LTL parser</li><li><a href="Ltl/index.html"><code>Ltl</code></a> - The LTL formul</li></ul><h2 id="algo"><a href="#algo" class="anchor"></a>The algorithm</h2><p><i>This algorithm is taken from the course <em>Introduction Ã  la vÃ©rification</em> written by <a href="https://www.labri.fr/profil/Zeitoun_ID1120210651">Marc Zeitoun</a>.</i></p><p>Let Ï† be an LTL formula.</p><h3 id="the-first-phase"><a href="#the-first-phase" class="anchor"></a>The first phase</h3><p>The first phase consists in putting Ï† in <i>negation normal form</i> (NNF), where:</p><ul><li>all negation appear only in front of the atomic propositions,</li><li>only other logical operators <code>âˆ§</code>, and <code>âˆ¨</code> can appear, and</li><li>only the temporal operator <code>X</code>, <code>U</code>, and <code>R</code> can appear.</li></ul><p>To calculate <i>nnf(Ï†)</i>, following rules can be applied recursively -- see <a href="Ltl/index.html#val-nnf"><code>Ltl.nnf</code></a>:</p><ul><li>nnf(Ï) = Ï</li><li>nnf(Â¬Â¬Ï†) = nnf(Ï†)</li><li>nnf(Â¬(Ï† âˆ¨ Ïˆ)) = nnf(Â¬Ï†) âˆ§ nnf(Â¬Ïˆ)</li><li>nnf(Â¬(Ï† âˆ§ Ïˆ)) = nnf(Â¬Ï†) âˆ¨ nnf(Â¬Ïˆ)</li><li>nnf(Â¬XÏ†) = X nnf(Â¬Ï†)</li><li>nnf(Â¬(Ï† U Ïˆ)) = nnf(Â¬Ï†) R nnf(Â¬Ïˆ)</li><li>nnf(Â¬(Ï† R Ïˆ)) = nnf(Â¬Ï†) U nnf(Â¬Ïˆ)</li></ul><h3 id="the-second-phase"><a href="#the-second-phase" class="anchor"></a>The second phase</h3><p>For the second phase, let reassign Ï† as <i>nnf(Ï†)</i> and define ğ’œ = (S, âŸ¶, S<sub>0</sub>, F<sub>1</sub>, ..., F<sub>k</sub>) as the equivalent BÃ¼chi automata of Ï†. An automata state s âˆˆ S is a subset of sub-formulas of Ï† and the initial state S<sub>0</sub> is {Ï†}.</p><h4 id="reduce"><a href="#reduce" class="anchor"></a>Reduced subset</h4><p>A subset Z of formulas in NNF is <b>reduced</b> if:</p><ul><li>formulas of Z are of the form: p, Â¬q, or XÎ±,</li><li>âŠ¥ âˆ‰ Z, and âˆ€.p âˆˆ AP, {p, Â¬p} âŠˆ Z.</li></ul><h4 id="transitions"><a href="#transitions" class="anchor"></a>Transitions</h4><p>In order to define transitions from a state Y, an oriented graph is build from Y. Let Y = Z âˆª {Î±} where Î± is not a <a href="#reduce">Reduced subset</a> and is <b>maximal</b> in Y (i.e. Î± is not a sub-formula of any other such formula of Y). Edges from Y are:</p><ul><li>If Î± = Î±<sub>1</sub> âˆ¨ Î±<sub>2</sub>, Y âŸ¶ Z âˆª {Î±<sub>1</sub>} and Y âŸ¶ Z âˆª {Î±<sub>2</sub>}.</li><li>If Î± = Î±<sub>1</sub> âˆ§ Î±<sub>2</sub>, Y âŸ¶ Z âˆª {Î±<sub>1</sub>, Î±<sub>2</sub>}.</li><li>If Î± = Î±<sub>1</sub> R Î±<sub>2</sub>, Y âŸ¶ Z âˆª {Î±<sub>1</sub>, Î±<sub>2</sub>} and Y âŸ¶ Z âˆª {XÎ±, Î±<sub>2</sub>}.</li><li>If Î± = Î±<sub>1</sub> U Î±<sub>2</sub>, Y âŸ¶ Z âˆª {Î±<sub>2</sub>} and Y âŸ¶<sup>Î±</sup> Z âˆª {XÎ±, Î±<sub>1</sub>}.</li></ul><p>The symbol âŸ¶<sup>Î±</sup> means the edge is <b>marked</b> by Î±.</p><p>Then, is defined:</p><ul><li>Red(Y) = {Z reduced | Y âŸ¶<sup>*</sup> Z}</li><li>Red<sub>Î±</sub>(Y) = {Z reduced | Y âŸ¶<sup>*</sup> without using an edge marked by Î±}</li></ul><p>When all formulas in Z are reduced, is defined:</p><ul><li>next(Z) = {Î± | XÎ± âˆˆ Z}</li><li>Î£<sub>Z</sub> the intersection of all p and Â¬p in Z.</li></ul><p>Finally, transitions from Y are: {Y âŸ¶<sup>Î£<sub>Z</sub></sup> next(Z) | Z âŠ† Red(Y)}. Is added an <b>acceptance condition</b> for each sub-formula Î± wich is an Until: F<sub>Î±</sub> = {Y âŸ¶<sup>Î£<sub>Z</sub></sup> next(Z) | Y âŠ† Q and Z âŠ† Red<sub>Î±</sub>(Y)}.</p><h4 id="genbuch"><a href="#genbuch" class="anchor"></a>Generalized BÃ¼chi automata on transitions</h4><p>At the end the automata built, is a generalized BÃ¼chi automata <i>on transitions</i>: it's similar to generalized BÃ¼chi automata except that <b>acceptance conditions are set of transitions</b> instead of set of states. A <b>run</b> from the initial state is accepted, if for each acceptance conditions, it goes infinitely often through a transition of this condition.</p><h4 id="summary"><a href="#summary" class="anchor"></a>Summary</h4><p>The automata ğ’œ = (S, âŸ¶, S<sub>0</sub>, F<sub>1</sub>, ..., F<sub>k</sub>) equivalent to the formula Ï†, is defined with:</p><ul><li>Initial state: S<sub>0</sub> = {Ï†}</li><li>Transitions from a state Y: {Y âŸ¶<sup>Î£<sub>Z</sub></sup> next(Z) | Z âŠ† Red(Y)}</li><li>Acceptance conditions: âˆ€.Î± âˆˆ Ï†, with Î± = Î±<sub>1</sub> U Î±<sub>2</sub>: F<sub>Î±</sub> = {Y âŸ¶<sup>Î£<sub>Z</sub></sup> next(Z) | Y âŠ† Q and Z âŠ† Red<sub>Î±</sub>(Y)}</li></ul></div></body></html>